// üîç RUTAS DE B√öSQUEDA V2.0
// src/routes/search.js

const express = require('express');
const SearchController = require('../controllers/searchController');
const { validateSearchParams } = require('../middleware/validation');
const rateLimit = require('express-rate-limit');

const router = express.Router();
const searchController = new SearchController();

// üìä Rate limiting para b√∫squedas
const searchLimiter = rateLimit({
  windowMs: 1 * 60 * 1000, // 1 minuto
  max: 60, // 60 b√∫squedas por minuto
  message: {
    error: 'SEARCH_RATE_LIMIT',
    message: 'Demasiadas b√∫squedas. M√°ximo 60 por minuto.',
    retryAfter: 60
  },
  standardHeaders: true,
  legacyHeaders: false
});

// üîß Middleware de logging
router.use((req, res, next) => {
  console.log(`[SEARCH-ROUTE] ${req.method} ${req.path} - Query:`, Object.keys(req.query));
  next();
});

// üìã **RUTAS PRINCIPALES DE B√öSQUEDA**

// üîç GET /api/search/inspections - B√∫squeda general de inspecciones
router.get('/inspections',
  searchLimiter,
  validateSearchParams,
  searchController.searchInspections.bind(searchController)
);

// üéØ POST /api/search/advanced - B√∫squeda avanzada con criterios complejos
router.post('/advanced',
  searchLimiter,
  searchController.advancedSearch.bind(searchController)
);

// üë®‚Äçüíº GET /api/search/driver/:driverId - Historial espec√≠fico de conductor
router.get('/driver/:driverId',
  searchController.searchDriverHistory.bind(searchController)
);

// üöó GET /api/search/vehicle/:placa - Historial espec√≠fico de veh√≠culo
router.get('/vehicle/:placa',
  searchController.searchVehicleHistory.bind(searchController)
);

// üö® GET /api/search/alerts - Alertas activas y cr√≠ticas
router.get('/alerts',
  searchController.getActiveAlerts.bind(searchController)
);

// üìä **RUTAS DE AN√ÅLISIS Y REPORTES**

// üìà GET /api/search/trends - An√°lisis de tendencias
router.get('/trends', async (req, res) => {
  try {
    console.log('[SEARCH-ROUTE] üìà Analizando tendencias...');
    
    const { 
      periodo = '30days',
      groupBy = 'day',
      metrics = 'all' 
    } = req.query;
    
    const { getPrismaClient } = require('../config/database');
    const prisma = getPrismaClient();
    
    // Calcular fecha de inicio
    const endDate = new Date();
    const startDate = new Date();
    
    switch (periodo) {
      case '7days':
        startDate.setDate(startDate.getDate() - 7);
        break;
      case '30days':
        startDate.setDate(startDate.getDate() - 30);
        break;
      case '90days':
        startDate.setDate(startDate.getDate() - 90);
        break;
      default:
        startDate.setDate(startDate.getDate() - 30);
    }
    
    // Obtener tendencias por d√≠a
    const trends = await prisma.inspeccion.groupBy({
      by: ['fecha'],
      where: {
        fecha: {
          gte: startDate,
          lte: endDate
        }
      },
      _count: {
        id: true
      },
      _sum: {
        kilometraje: true,
        marca_temporal: true
      },
      _avg: {
        kilometraje: true,
        marca_temporal: true
      },
      orderBy: {
        fecha: 'asc'
      }
    });
    
    // Procesar datos para el frontend
    const processedTrends = trends.map(item => ({
      fecha: item.fecha.toISOString().split('T')[0],
      totalInspecciones: item._count.id,
  // Eliminados: alertasRojas, advertencias, medicamentos, suenoInsuficiente, sintomasFatiga, noAptos, puntajePromedio, tasaAlertasRojas, tasaAdvertencias
    }));
    
    // Calcular estad√≠sticas generales del per√≠odo
    const totalInspecciones = processedTrends.reduce((sum, item) => sum + item.totalInspecciones, 0);
    const totalAlertas = processedTrends.reduce((sum, item) => sum + item.alertasRojas, 0);
    const totalAdvertencias = processedTrends.reduce((sum, item) => sum + item.advertencias, 0);
    
    const response = {
      periodo: {
        inicio: startDate.toISOString().split('T')[0],
        fin: endDate.toISOString().split('T')[0],
        dias: processedTrends.length
      },
      tendencias: processedTrends,
      resumen: {
        totalInspecciones,
        totalAlertas,
        totalAdvertencias,
        tasaPromediaAlertas: totalInspecciones > 0 ? Math.round(totalAlertas / totalInspecciones * 100 * 100) / 100 : 0,
        tasaPromediaAdvertencias: totalInspecciones > 0 ? Math.round(totalAdvertencias / totalInspecciones * 100 * 100) / 100 : 0,
        puntajePromedioGeneral: processedTrends.length > 0 ? 
          Math.round(processedTrends.reduce((sum, item) => sum + item.puntajePromedio, 0) / processedTrends.length * 100) / 100 : 0
      },
      // üö® AN√ÅLISIS DE FATIGA EN TENDENCIAS
      analisisFatiga: {
  totalMedicamentos: processedTrends.reduce((sum, item) => sum + (item.medicamentos || 0), 0),
  totalSuenoInsuficiente: processedTrends.reduce((sum, item) => sum + (item.suenoInsuficiente || 0), 0),
  totalSintomasFatiga: processedTrends.reduce((sum, item) => sum + (item.sintomasFatiga || 0), 0),
  totalNoAptos: processedTrends.reduce((sum, item) => sum + (item.noAptos || 0), 0),
  tendenciaFatiga: calculateFatigueTrend(processedTrends)
      }
    };
    
    console.log(`[SEARCH-ROUTE] ‚úÖ Tendencias analizadas: ${processedTrends.length} d√≠as de datos`);
    
    res.json({
      success: true,
      data: response,
      message: 'An√°lisis de tendencias completado'
    });
    
  } catch (error) {
    console.error('[SEARCH-ROUTE] ‚ùå Error analizando tendencias:', error);
    res.status(500).json({
      success: false,
      error: 'TRENDS_ERROR',
      message: error.message
    });
  }
});

// üìä GET /api/search/summary/:type - Res√∫menes por categor√≠a
router.get('/summary/:type', async (req, res) => {
  try {
    const { type } = req.params;
    const { timeframe = '30days', limit = 10 } = req.query;
    
    console.log(`[SEARCH-ROUTE] üìä Generando resumen de tipo: ${type}`);
    
    const { getPrismaClient } = require('../config/database');
    const prisma = getPrismaClient();
    
    let summary = {};
    
    switch (type) {
      case 'conductores':
        summary = await this.getConductoresSummary(prisma, timeframe, limit);
        break;
      case 'vehiculos':
        summary = await this.getVehiculosSummary(prisma, timeframe, limit);
        break;
      case 'contratos':
        summary = await this.getContratosSummary(prisma, timeframe, limit);
        break;
      case 'fatiga':
          // Llamar correctamente al m√©todo del controlador
          if (typeof searchController.getFatigaSummary === 'function') {
            summary = await searchController.getFatigaSummary(prisma, timeframe);
          } else {
            return res.status(500).json({ success: false, error: 'FATIGA_SUMMARY_NOT_IMPLEMENTED' });
          }
        break;
      default:
        return res.status(400).json({
          success: false,
          error: 'INVALID_SUMMARY_TYPE',
          message: 'Tipo de resumen no v√°lido',
          validTypes: ['conductores', 'vehiculos', 'contratos', 'fatiga']
        });
    }
    
    console.log(`[SEARCH-ROUTE] ‚úÖ Resumen de ${type} generado`);
    
    res.json({
      success: true,
      data: {
        type,
        timeframe,
        summary,
        generatedAt: new Date().toISOString()
      },
      message: `Resumen de ${type} generado`
    });
    
  } catch (error) {
    console.error('[SEARCH-ROUTE] ‚ùå Error generando resumen:', error);
    res.status(500).json({
      success: false,
      error: 'SUMMARY_ERROR',
      message: error.message
    });
  }
});

// üîÑ GET /api/search/refresh/:type - Refrescar cache de b√∫squedas
router.post('/refresh/:type?', (req, res) => {
  try {
    const { type = 'all' } = req.params;
    
    console.log(`[SEARCH-ROUTE] üîÑ Refrescando cache: ${type}`);
    
    // TODO: Implementar sistema de cache y refresh
    // Por ahora, simplemente confirmamos la acci√≥n
    
    res.json({
      success: true,
      message: `Cache de ${type} refrescado`,
      timestamp: new Date().toISOString(),
      note: 'Sistema de cache en desarrollo - pr√≥xima versi√≥n'
    });
    
  } catch (error) {
    console.error('[SEARCH-ROUTE] ‚ùå Error refrescando cache:', error);
    res.status(500).json({
      success: false,
      error: 'CACHE_REFRESH_ERROR', 
      message: error.message
    });
  }
});

// üì§ POST /api/search/export - Exportar resultados de b√∫squeda
router.post('/export', async (req, res) => {
  try {
    console.log('[SEARCH-ROUTE] üì§ Iniciando exportaci√≥n...');
    
    const {
      searchParams,      // Par√°metros de b√∫squeda
      format = 'json',   // Formato: json, csv, excel, pdf
      filename,          // Nombre del archivo
      includeCharts = false, // Incluir gr√°ficos (para PDF)
      template = 'standard'  // Plantilla de reporte
    } = req.body;
    
    if (!searchParams) {
      return res.status(400).json({
        success: false,
        error: 'SEARCH_PARAMS_REQUIRED',
        message: 'Par√°metros de b√∫squeda requeridos para exportar'
      });
    }
    
    // Ejecutar b√∫squeda con los par√°metros proporcionados
    // Por ahora, simularemos los resultados
    const searchResults = {
      inspecciones: [], // Resultados de b√∫squeda
      totalFound: 0,
      searchParams: searchParams
    };
    
    // TODO: Implementar exportaci√≥n real seg√∫n formato
    switch (format) {
      case 'json':
        res.json({
          success: true,
          data: searchResults,
          format: 'json',
          message: 'Datos exportados en formato JSON'
        });
        break;
        
      case 'csv':
        res.status(501).json({
          success: false,
          error: 'FORMAT_NOT_IMPLEMENTED',
          message: 'Exportaci√≥n CSV estar√° disponible en pr√≥xima versi√≥n'
        });
        break;
        
      case 'excel':
        res.status(501).json({
          success: false,
          error: 'FORMAT_NOT_IMPLEMENTED',
          message: 'Exportaci√≥n Excel estar√° disponible en pr√≥xima versi√≥n'
        });
        break;
        
      case 'pdf':
        // Esta funcionalidad la implementaremos en el servicio de reportes PDF
        res.status(501).json({
          success: false,
          error: 'FORMAT_NOT_IMPLEMENTED',
          message: 'Exportaci√≥n PDF estar√° disponible en pr√≥xima versi√≥n'
        });
        break;
        
      default:
        res.status(400).json({
          success: false,
          error: 'INVALID_FORMAT',
          message: 'Formato no v√°lido',
          supportedFormats: ['json', 'csv', 'excel', 'pdf']
        });
    }
    
  } catch (error) {
    console.error('[SEARCH-ROUTE] ‚ùå Error en exportaci√≥n:', error);
    res.status(500).json({
      success: false,
      error: 'EXPORT_ERROR',
      message: error.message
    });
  }
});

// üß™ GET /api/search/test - Test de conectividad de b√∫squedas
router.get('/test', (req, res) => {
  console.log('[SEARCH-ROUTE] üß™ Test endpoint ejecutado');
  
  res.json({
    success: true,
    message: 'Search routes funcionando correctamente',
    timestamp: new Date().toISOString(),
    endpoints: [
      'GET /api/search/inspections - B√∫squeda general',
      'POST /api/search/advanced - B√∫squeda avanzada',
      'GET /api/search/driver/:id - Historial conductor',
      'GET /api/search/vehicle/:placa - Historial veh√≠culo',
      'GET /api/search/alerts - Alertas activas',
      'GET /api/search/trends - An√°lisis tendencias',
      'GET /api/search/summary/:type - Res√∫menes',
      'POST /api/search/export - Exportar resultados'
    ],
    features: [
      'üîç B√∫squeda de texto libre en m√∫ltiples campos',
      'üìÖ Filtros por fecha y per√≠odo',
      'üö® B√∫squeda espec√≠fica de alertas y riesgos',
      'üë®‚Äçüíº Historial completo de conductores',
      'üöó An√°lisis de veh√≠culos',
      'üìà Tendencias temporales',
      'üìä Res√∫menes por categor√≠a',
      'üì§ Exportaci√≥n en m√∫ltiples formatos'
    ]
  });
});

// üîß M√âTODOS AUXILIARES

// Calcular tendencia de fatiga
function calculateFatigueTrend(data) {
  if (data.length < 2) return 'sin-datos';
  
  const firstHalf = data.slice(0, Math.floor(data.length / 2));
  const secondHalf = data.slice(Math.floor(data.length / 2));
  
  const firstAvg = firstHalf.reduce((sum, item) => sum + (item.medicamentos + item.suenoInsuficiente + item.sintomasFatiga), 0) / firstHalf.length;
  const secondAvg = secondHalf.reduce((sum, item) => sum + (item.medicamentos + item.suenoInsuficiente + item.sintomasFatiga), 0) / secondHalf.length;
  
  if (secondAvg > firstAvg * 1.2) return 'empeorando';
  if (secondAvg < firstAvg * 0.8) return 'mejorando';
  return 'estable';
}

// M√©todos auxiliares para res√∫menes (implementaci√≥n b√°sica)
async function getConductoresSummary(prisma, timeframe, limit) {
  return {
    topConductores: [],
    problemasRecurrentes: [],
    mejorDesempeno: [],
    note: 'Implementaci√≥n completa en desarrollo'
  };
}

async function getVehiculosSummary(prisma, timeframe, limit) {
  return {
    vehiculosProblematicos: [],
    mantenimientoRequerido: [],
    mejorEstado: [],
    note: 'Implementaci√≥n completa en desarrollo'
  };
}

async function getContratosSummary(prisma, timeframe, limit) {
  return {
    rendimientoPorContrato: [],
    problemasRecurrentes: [],
    mejorDesempeno: [],
    note: 'Implementaci√≥n completa en desarrollo'
  };
}

async function getFatigaSummary(prisma, timeframe) {
  const cutoffDate = new Date();
  cutoffDate.setDate(cutoffDate.getDate() - (timeframe === '7days' ? 7 : timeframe === '90days' ? 90 : 30));
  
  const fatigueStats = await prisma.inspeccion.aggregate({
    where: {
      fecha: { gte: cutoffDate }
    },
    _count: {
      id: true
    },
    _sum: {
      consumo_medicamentos: true,
      horas_sueno_suficientes: true,
      libre_sintomas_fatiga: true,
      condiciones_aptas: true
    }
  });
  
  const total = fatigueStats._count.id || 0;
  
  return {
    totalInspecciones: total,
    medicamentos: fatigueStats._sum.consumo_medicamentos || 0,
    suenoInsuficiente: total - (fatigueStats._sum.horas_sueno_suficientes || 0),
    sintomasFatiga: total - (fatigueStats._sum.libre_sintomas_fatiga || 0),
    noAptos: total - (fatigueStats._sum.condiciones_aptas || 0),
    porcentajes: {
      medicamentos: total > 0 ? Math.round((fatigueStats._sum.consumo_medicamentos || 0) / total * 100 * 100) / 100 : 0,
      problemasGenerales: total > 0 ? Math.round((total - (fatigueStats._sum.horas_sueno_suficientes || 0) + total - (fatigueStats._sum.libre_sintomas_fatiga || 0) + total - (fatigueStats._sum.condiciones_aptas || 0)) / (total * 3) * 100 * 100) / 100 : 0
    }
  };
}

module.exports = router;